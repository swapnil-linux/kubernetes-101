# 5. Deployments

In this chapter, you’ll see how to use Deployments to bring cloud-native features such as self-healing, scaling, rolling updates, and versioned rollbacks to stateless apps on Kubernetes. Deployments are extremely useful and you’ll use them all the time.

Kubernetes offers several controllers that augment Pods with important capabilities. The Deployment controller is specifically designed for stateless apps. We’ll cover other controllers later in the course.

Throughout the chapter, we’ll use terms like release, rollout, and rolling update to mean the same thing – pushing a new version of an app.

## Deployment theory

There are two major components to Deployments.

1\. The spec\
2\. The controller

The Deployment spec is a declarative YAML object where you describe the desired state of a stateless app. You give it to Kubernetes where the Deployment controller implements and manages it. The controller element is highly-available and operates as a background loop, on the control plane, reconciling the observed state with the desired state.

The latest version of the Deployment object, including all features and attributes, is defined in the apps/v1 workloads API sub-group.

```
[centos@ip-10-0-2-94 ~]$ kubectl api-resources |grep -Ew 'deployments|NAME'
NAME                              SHORTNAMES   APIVERSION                             NAMESPACED   KIND
deployments                       deploy       apps/v1                                true         Deployment
[centos@ip-10-0-2-94 ~]$ 
```

You start with a stateless application, package it as a container, then define it in a Pod template. At this point you could run it on Kubernetes. However, static Pods like this don’t self-heal, they don’t scale, and they don’t allow for easy updates and rollbacks. For these reasons, you’ll almost always wrap them in a Deployment object.

![](<.gitbook/assets/Screen Shot 2022-06-23 at 4.34.50 pm.png>)

You post the Deployment object to the API server where Kubernetes implements it and the Deployment controller watches it.

## Deployments and Pods

A Deployment object only manages a single Pod template. For example, an application with a front-end web service and a shopping basket service will have a different Pod\
for each (two Pod templates). As a result, it’ll need two Deployment objects – one managing front-end web Pods, the other managing any shopping basket Pods. However, a Deployment can manage multiple replicas of the same Pod. For example, the front-end web Deployment might be managing 5 identical replicas of the front-end web Pod.

## Deployments and ReplicaSets

Behind-the-scenes, Deployments rely heavily on another object called a ReplicaSet. While it’s recommended not to manage ReplicaSets directly (let the Deployment controller manage them), it’s important to understand the role they play.

At a high-level, containers are a great way to package applications and dependencies. Pods allow containers to run on Kubernetes and enable co-scheduling and a bunch of other good stuff. ReplicaSets manage Pods and bring self-healing and scaling. Deployments manage ReplicaSets and add rollouts and rollbacks. As a result, working with Deployments brings the benefits of everything else – the container, the Pod, the ReplicaSet.

![](<.gitbook/assets/Screen Shot 2022-06-23 at 4.37.32 pm.png>)

Think of Deployments as managing ReplicaSets, and ReplicaSets as managing Pods. Put them together, and you’ve got a great way to deploy and manage stateless applications on Kubernetes.

## Self-healing and scalability

Pods are great. They let you co-locate containers, share volumes, share memory, simplify networking, and a lot more. But they offer nothing in the way of self-healing and scalability – if the node a Pod is running on fails, the Pod is lost.

Enter Deployments...

• If Pods managed by a Deployment fail, they will be replaced – _self-healing_\
• If Pods managed by a Deployment see increased or decreased load, they can be _scaled_

Remember though, hidden away behind-the-scenes, it’s actually the ReplicaSets doing the self-healing and scalability. You’ll see them in action soon.

## It’s all about the state

Before going any further, it’s critical to understand three concepts that are fundamental to everything about Kubernetes:

* Desired state
* Observed state (sometimes called actual state or current state)
* Reconciliation

_Desired_ state is what you **want**. _Observed_ state is what you **have**. If they match, everybody’s happy. If they don’t match, a process of _reconciliation_ attempts to bring observed state into **sync** with desired state.

## Rolling updates with Deployments

