# 6. Kubernetes Service

In previous chapters, you’ve deployed applications to Kubernetes and seen how controllers add self-healing, scaling and rollouts. Despite all of this, Pods are still unreliable and you should never connect directly to them. This is where Services come to the rescue by providing stable and reliable networking for a set of unreliable Pods.

When Pods fail, they get replaced by new ones with new IPs. Scaling-up introduces new Pods with new IP addresses. Scaling down removes Pods. Rolling updates delete existing Pods and replace them with new ones with new IPs. All of this creates massive IP churn and demonstrates why you should never connect directly to any Pod.

#### You also need to know 3 fundamental things about Kubernetes Services.

1\) Service object in Kubernetes provides stable networking for Pods. Just like a Pod, ReplicaSet, or Deployment, a Kubernetes Service is a REST object in the API that you define in a manifest file and post to the API server.

2\) Every Service gets its own stable IP address, its own stable DNS name, and its own stable port.

3\) Services use labels and selectors to dynamically select the Pods they send traffic to.

## Service Theory

The below figure shows a simple application managed by a Deployment controller. There’s a client (which could be another Pod) that needs a reliable network endpoint to access the Pods. Remember, it’s a bad idea to talk directly to individual Pods because scaling operations, rollouts, rollbacks, and even failures can make them disappear.

![](<.gitbook/assets/Screen Shot 2022-06-25 at 4.11.14 pm.png>)

The below figure shows the same application with a Service thrown into the mix. The Service fronts the Pods with a stable IP, DNS name, and port. It also load-balances traffic to Pods with the right labels.

![](<.gitbook/assets/Screen Shot 2022-06-25 at 4.12.09 pm.png>)

With a Service in place, the Pods can scale up and down, they can fail, and they can be updated and rolled back. Despite all of this, clients will continue to access them without interruption. This is because the Service is observing the changes and updating its list of healthy Pods it sends traffic to. But it never changes its stable IP, DNS, and port.

### Labels and loose coupling

Services are loosely coupled with Pods via labels and selectors. This is the same technology that loosely couples Deployments to Pods and is key to the flexibility of Kubernetes. Below Figure shows an example where 3 Pods are labelled as `zone=prod` and `ver=v1`, and the Service has a selector that matches.

![](<.gitbook/assets/Screen Shot 2022-06-25 at 4.14.34 pm.png>)

#### For a Service to send traffic to a Pod, the Pod needs every label the Service is selecting on.&#x20;

![](<.gitbook/assets/Screen Shot 2022-06-25 at 4.16.36 pm.png>)

#### It can also have additional labels the Service isn’t looking for.

![](<.gitbook/assets/Screen Shot 2022-06-25 at 4.17.15 pm.png>)

The following excerpts, from a Service YAML and Deployment YAML, show how selectors and labels work.

```
[centos@ip-10-0-2-94 ~]$ cat ~/kubernetes-101/labs/ns/shield-app.yml 
apiVersion: v1
kind: Service
metadata:
  namespace: shield
  name: the-bus
spec:
  type: NodePort
  ports:
  - nodePort: 31112
    port: 8080
    targetPort: 8080
  selector:
    env: marvel       <<======= Send to Pods with these labels
---
apiVersion: v1
kind: Pod
metadata:
  namespace: shield
  name: triskelion
  labels:
    env: marvel   <<======= Pod Labels
spec:
  containers:
  - image: quay.io/mask365/scaling:latest
    name: bus-ctr
    ports:
    - containerPort: 8080
    imagePullPolicy: Always
[centos@ip-10-0-2-94 ~]$ 
```

